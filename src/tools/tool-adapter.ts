/**
 * Tool Adapter Interface and Types
 *
 * Defines the abstraction layer for integrating various AI coding tools
 * (Auggie, Claude Code, Pi, OpenCode, Codex, Gemini, Llama) into the
 * consensus-coder system.
 *
 * Each tool can act as either a context-engine (generates solutions) or
 * a reviewer (votes on solutions). The ToolAdapter interface provides
 * a unified API for both roles.
 *
 * @version 1.0
 */

// ============================================================================
// 1. TOOL NAME - Supported Tools
// ============================================================================

/**
 * Union type of all supported tool names in the consensus-coder system.
 *
 * Each tool represents an AI coding assistant that can participate in
 * the consensus process either as a solution generator or reviewer.
 *
 * @type {'auggie' | 'claude-code' | 'pi' | 'opencode' | 'codex' | 'gemini' | 'llama'}
 */
export type ToolName =
  | 'auggie' // Augment's Auggie CLI tool
  | 'claude-code' // Claude Code assistant
  | 'pi' // Pi assistant
  | 'opencode' // OpenCode tool
  | 'codex' // OpenAI Codex
  | 'gemini' // Google Gemini
  | 'llama'; // Meta Llama

// ============================================================================
// 2. TOOL ROLE - Role in Consensus Process
// ============================================================================

/**
 * The role a tool plays in the consensus process.
 *
 * - context-engine: Generates solutions from codebase context
 * - reviewer: Reviews and votes on solutions from other tools
 *
 * @type {'context-engine' | 'reviewer'}
 */
export type ToolRole = 'context-engine' | 'reviewer';

// ============================================================================
// 3. TOOL CONFIG - Configuration for Tool Initialization
// ============================================================================

/**
 * Configuration options for initializing a tool adapter.
 *
 * Provides settings for both CLI-based tools (path, timeout) and
 * API-based tools (apiKey, model, temperature).
 *
 * @interface ToolConfig
 */
export interface ToolConfig {
  /**
   * The name of the tool being configured.
   *
   * @type {ToolName}
   */
  name: ToolName;

  /**
   * Path to the binary for CLI-based tools.
   * Not required for API-based tools.
   *
   * @type {string | undefined}
   * @example '/usr/local/bin/auggie'
   */
  path?: string;

  /**
   * Timeout in milliseconds for tool operations.
   * Applies to both CLI execution and API calls.
   *
   * @type {number | undefined}
   * @constraints > 0, typically 30000-120000
   */
  timeout?: number;

  /**
   * API key for API-based tools.
   * Not required for local CLI tools.
   *
   * @type {string | undefined}
   */
  apiKey?: string;

  /**
   * Specific model version to use.
   * E.g., 'claude-opus-4-5', 'gemini-2.0-flash', 'gpt-4o'
   *
   * @type {string | undefined}
   */
  model?: string;

  /**
   * Sampling temperature for response generation.
   * Higher values = more creative, lower = more deterministic.
   *
   * @type {number | undefined}
   * @constraints 0.0 <= temperature <= 2.0
   */
  temperature?: number;
}

// ============================================================================
// 4. TOOL SOLUTION - Standardized Solution Format
// ============================================================================

/**
 * Standardized solution format returned by context engines.
 *
 * Provides a consistent structure for solutions generated by any tool,
 * enabling fair comparison and voting across different AI models.
 *
 * @interface ToolSolution
 */
export interface ToolSolution {
  /**
   * Unique identifier for this solution.
   * Format: `{toolName}-{timestamp}-{hash}`
   *
   * @type {string}
   * @constraints Non-empty, unique within a round
   */
  solutionId: string;

  /**
   * Short descriptive name for the solution.
   * E.g., "Binary Search Approach", "Recursive DFS Solution"
   *
   * @type {string}
   * @constraints Non-empty, < 100 characters
   */
  name: string;

  /**
   * Brief description of what the solution does.
   * 2-3 sentences explaining the approach.
   *
   * @type {string}
   * @constraints Non-empty, < 500 characters
   */
  description: string;

  /**
   * The actual implementation code.
   *
   * @type {string}
   * @constraints Non-empty, < 50,000 characters
   */
  code: string;

  /**
   * Programming language of the code.
   * E.g., 'typescript', 'python', 'rust', 'go'
   *
   * @type {string}
   * @constraints Non-empty, lowercase
   */
  language: string;

  /**
   * Detailed rationale explaining why this approach was chosen.
   * Includes design decisions and key considerations.
   *
   * @type {string}
   * @constraints Non-empty, < 2,000 characters
   */
  rationale: string;

  /**
   * Time and space complexity analysis.
   *
   * @type {{ time: string; space: string }}
   * @property time - Big-O time complexity (e.g., "O(n log n)")
   * @property space - Big-O space complexity (e.g., "O(n)")
   */
  complexity: {
    time: string;
    space: string;
  };

  /**
   * Trade-offs of this solution approach.
   * Lists compromises made in the design.
   *
   * @type {string[]}
   * @constraints Each item < 200 characters
   */
  tradeoffs: string[];

  /**
   * Potential risks or issues with this solution.
   * Known limitations or edge cases that may cause problems.
   *
   * @type {string[]}
   * @constraints Each item < 200 characters
   */
  risks: string[];

  /**
   * Confidence level in this solution (0-100).
   * Higher values indicate greater certainty in correctness and quality.
   *
   * @type {number}
   * @constraints 0 <= confidence <= 100
   */
  confidence: number;
}

// ============================================================================
// 5. TOOL VOTE - Standardized Vote Format
// ============================================================================

/**
 * Standardized vote format from reviewers.
 *
 * Captures a reviewer's evaluation of all solutions in a round,
 * including their selection, reasoning, and per-solution scores.
 *
 * @interface ToolVote
 */
export interface ToolVote {
  /**
   * The tool that cast this vote.
   *
   * @type {ToolName}
   */
  voterId: ToolName;

  /**
   * The solutionId of the selected/preferred solution.
   *
   * @type {string}
   * @constraints Must match a valid solutionId from the solutions list
   */
  selectedSolutionId: string;

  /**
   * Confidence level in this vote (0-100).
   * Higher values indicate greater certainty in the selection.
   *
   * @type {number}
   * @constraints 0 <= confidence <= 100
   */
  confidence: number;

  /**
   * Explanation of why this solution was selected.
   * Detailed reasoning for the vote.
   *
   * @type {string}
   * @constraints Non-empty, < 2,000 characters
   */
  reasoning: string;

  /**
   * Concerns or reservations about the selected solution.
   * Issues that were considered but not disqualifying.
   *
   * @type {string[]}
   * @constraints Each item < 300 characters
   */
  concerns: string[];

  /**
   * Suggestions for improving the selected solution.
   * Recommendations for refinement.
   *
   * @type {string[]}
   * @constraints Each item < 300 characters
   */
  suggestions: string[];

  /**
   * Numeric ratings for each solution (1-10 scale).
   * Keys are solutionIds, values are scores.
   *
   * @type {{ [solutionId: string]: number }}
   * @constraints Each score: 1 <= score <= 10
   */
  scores: { [solutionId: string]: number };
}

// ============================================================================
// 6. TOOL GENERATE REQUEST - Request for Solution Generation
// ============================================================================

/**
 * Request payload for generating solutions.
 *
 * Sent to context-engine tools to generate one or more solutions
 * for a given problem.
 *
 * @interface ToolGenerateRequest
 */
export interface ToolGenerateRequest {
  /**
   * The problem statement to solve.
   *
   * @type {string}
   * @constraints Non-empty, < 10,000 characters
   */
  problem: string;

  /**
   * Codebase context relevant to the problem.
   * Includes relevant code snippets, file paths, and dependencies.
   *
   * @type {string}
   * @constraints Non-empty, < 50,000 characters
   */
  context: string;

  /**
   * Optional constraints or requirements for the solution.
   * E.g., "Use TypeScript", "Must be thread-safe", "O(n) complexity"
   *
   * @type {string[] | undefined}
   * @constraints Each item < 500 characters
   */
  constraints?: string[];

  /**
   * Synthesis from the previous round (if any).
   * Provides context on what was discussed/decided previously.
   *
   * @type {string | undefined}
   * @constraints < 10,000 characters if defined
   */
  previousRoundSynthesis?: string;

  /**
   * Number of solutions to generate.
   * Default: 3
   *
   * @type {number | undefined}
   * @constraints 1 <= numSolutions <= 5, default 3
   */
  numSolutions?: number;
}

// ============================================================================
// 7. TOOL REVIEW REQUEST - Request for Solution Review
// ============================================================================

/**
 * Request payload for reviewing solutions.
 *
 * Sent to reviewer tools to evaluate and vote on solutions
 * generated by context-engine tools.
 *
 * @interface ToolReviewRequest
 */
export interface ToolReviewRequest {
  /**
   * The original problem statement.
   *
   * @type {string}
   * @constraints Non-empty, < 10,000 characters
   */
  problem: string;

  /**
   * Codebase context relevant to the problem.
   * Same context provided to solution generators.
   *
   * @type {string}
   * @constraints Non-empty, < 50,000 characters
   */
  context: string;

  /**
   * The solutions to review.
   * Generated by context-engine tools in this round.
   *
   * @type {ToolSolution[]}
   * @constraints Non-empty array
   */
  solutions: ToolSolution[];

  /**
   * Previous review votes from other reviewers (if any).
   * Allows reviewers to consider other perspectives.
   *
   * @type {ToolVote[] | undefined}
   */
  previousReviews?: ToolVote[];
}

// ============================================================================
// 8. TOOL ADAPTER - Abstract Interface for All Tools
// ============================================================================

/**
 * Abstract interface for all AI coding tools.
 *
 * Provides a unified API for integrating various AI coding assistants
 * into the consensus-coder system. Implementations handle the specifics
 * of communicating with each tool (CLI, API, etc.).
 *
 * @interface ToolAdapter
 *
 * @example
 * ```typescript
 * const auggie: ToolAdapter = new AuggieAdapter();
 * await auggie.initialize({ name: 'auggie', path: '/usr/local/bin/auggie' });
 *
 * if (await auggie.isAvailable()) {
 *   const solutions = await auggie.generateSolutions({
 *     problem: 'Implement a LRU cache',
 *     context: '// existing cache code...',
 *     numSolutions: 3
 *   });
 * }
 *
 * await auggie.dispose();
 * ```
 */
export interface ToolAdapter {
  /**
   * The name of this tool.
   * Used for identification and logging.
   *
   * @readonly
   * @type {ToolName}
   */
  readonly name: ToolName;

  /**
   * The role this tool plays in the consensus process.
   * Determines whether it generates solutions or reviews them.
   *
   * @readonly
   * @type {ToolRole}
   */
  readonly role: ToolRole;

  /**
   * Initialize the tool adapter with configuration.
   *
   * Sets up connections, validates paths, and prepares the tool
   * for operation. Must be called before other methods.
   *
   * @param config - Configuration options for the tool
   * @returns Promise that resolves when initialization is complete
   * @throws Error if initialization fails (e.g., binary not found, invalid API key)
   */
  initialize(config: ToolConfig): Promise<void>;

  /**
   * Check if the tool is available and ready to use.
   *
   * Verifies that the tool can be invoked (binary exists, API reachable, etc.).
   * Should be called after initialize() to confirm readiness.
   *
   * @returns Promise resolving to true if tool is available, false otherwise
   */
  isAvailable(): Promise<boolean>;

  /**
   * Generate solutions for a given problem.
   *
   * Primary method for context-engine tools. Analyzes the problem and
   * codebase context to produce one or more solution proposals.
   *
   * @param request - The generation request with problem and context
   * @returns Promise resolving to an array of solutions
   * @throws Error if generation fails or tool is not a context-engine
   */
  generateSolutions(request: ToolGenerateRequest): Promise<ToolSolution[]>;

  /**
   * Review solutions and provide a vote.
   *
   * Primary method for reviewer tools. Evaluates all solutions and
   * produces a structured vote with scores and reasoning.
   *
   * @param request - The review request with problem, context, and solutions
   * @returns Promise resolving to a vote
   * @throws Error if review fails or tool is not a reviewer
   */
  reviewSolutions(request: ToolReviewRequest): Promise<ToolVote>;

  /**
   * Clean up resources and close connections.
   *
   * Should be called when the tool is no longer needed.
   * Releases any held resources (file handles, connections, etc.).
   *
   * @returns Promise that resolves when disposal is complete
   */
  dispose(): Promise<void>;
}

